---
title: 이벤트 설계의 포인트들
published: 2025-08-20
description: "개발자라면 놓치지 말아야 할 이벤트 설계의 핵심 포인트와 실전 사례를 정리한 글입니다."
image: ""
tags: ["Event", "Taxonomy", "Tracking"]
category: Guide
draft: false
---

# 개발자라면 놓치지 말아야 할 이벤트 설계의 포인트들

<!-- TOC depthfrom:2 -->

- [저는 디바이스가 5개 있는데요?](#%EC%A0%80%EB%8A%94-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EA%B0%80-5%EA%B0%9C-%EC%9E%88%EB%8A%94%EB%8D%B0%EC%9A%94)
  - [이게 왜 문제인데?](#%EC%9D%B4%EA%B2%8C-%EC%99%9C-%EB%AC%B8%EC%A0%9C%EC%9D%B8%EB%8D%B0)
  - [로그인 기능이 있다면?](#%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%9E%88%EB%8B%A4%EB%A9%B4)
  - [로그인 기능이 없다면?](#%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%97%86%EB%8B%A4%EB%A9%B4)
- [이벤트의 홍수에 휩쓸리다...](#%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%9D%98-%ED%99%8D%EC%88%98%EC%97%90-%ED%9C%A9%EC%93%B8%EB%A6%AC%EB%8B%A4)
- [과식보단 소식이 건강에 좋다](#%EA%B3%BC%EC%8B%9D%EB%B3%B4%EB%8B%A8-%EC%86%8C%EC%8B%9D%EC%9D%B4-%EA%B1%B4%EA%B0%95%EC%97%90-%EC%A2%8B%EB%8B%A4)
- [찌를 때마다 돈입니다... Debounce & Throttle](#%EC%B0%8C%EB%A5%BC-%EB%95%8C%EB%A7%88%EB%8B%A4-%EB%8F%88%EC%9E%85%EB%8B%88%EB%8B%A4-debounce--throttle)
- [이벤트 네이밍, 변수명만큼 중요하다](#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EB%B3%80%EC%88%98%EB%AA%85%EB%A7%8C%ED%81%BC-%EC%A4%91%EC%9A%94%ED%95%98%EB%8B%A4)
  - [네이밍이 잘못되면?](#%EB%84%A4%EC%9D%B4%EB%B0%8D%EC%9D%B4-%EC%9E%98%EB%AA%BB%EB%90%98%EB%A9%B4)
  - [그래서 어떤 방식이 좋을까?](#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C)
  - [중요한 건 일관성](#%EC%A4%91%EC%9A%94%ED%95%9C-%EA%B1%B4-%EC%9D%BC%EA%B4%80%EC%84%B1)

<!-- /TOC -->

## 1. 저는 디바이스가 5개 있는데요?

문제: 하나의 유저가 여러 디바이스에서 활동하면 어떻게 추적할까?

- A라는 유저가 스마트폰 2개와 태블릿, 노트북에서 로그인해서 활동합니다.
- 그런데 클라이언트에서 자동 생성되는 식별자(Device ID)는 디바이스마다 다릅니다.
- 서버에서는 유저 계정 ID(예: user_123)가 기준입니다.
- 이 둘이 연결되지 않으면, Amplitude나 Firebase에서는 동일 유저로 묶이지 않고 서로 다른 사람처럼 보이게 됩니다.

### 이게 왜 문제인데?

앱을 운영함에 있어 유저수를 파악하는 것은 아주 중요한 문제이다.
예를 들어... 내가 다이어트를 한다고 가정하면 오늘 몇 칼로리를 먹었는지, 운동을 했다면 어떤 종류의 운동을 몇키로 몇회 몇세트를 했는지, 시험 문제풀이를 했다면 어떤 종류의 문제를 얼마큼 풀고 어떤게 틀렸는지를 알고 싶을 것이다.

그러나 각각의 카테고리에서 칼로리, 어떤 운동, 문제 푼 기록에 대한 것들이 어딘가로 휘발되어 사라져버렸다면(머릿 속 에서도 사라져 버렸다고 가정하자. 요즘은 디지털 치매의 시대니까) 나의 다이어트... 운동... 시험 준비를 운영함에 있어 아주 큰 장애가 발생하게 될 것이다.

그래서, 다시 원점으로 돌아가, 각각의 디바이스에서 나의 이름모를 서비스에 접속한 유저수를 정확하게 파악하는 방법을 탐구해보자!

### 로그인 기능이 있다면?

로그인 시 **user_id를 명시적으로 설정**하고, 디바이스마다 발행되는 식별자(device_id)를 해당 user_id와 **identify 병합**하면 된다. (이른바 맵핑) 이는 Amplitude나 Segment 등 대부분의 툴에서 기본적으로 제공하는 기능이다.

- 로그인 전: anonymous_id = 디바이스 식별자
- 로그인 후: user_id → 이전 이벤트와 연결

### 로그인 기능이 없다면?

이 경우는 복잡... 혹은 답이 없다. 유저가 동일한 행동을 여러 디바이스에서 했다고 해도, 각 디바이스는 서로 다른 anonymous_id를 갖게 된다. 이 경우 유저 단위 분석이 불가능해질 수 있는데...

예외적인 해결책은 있을지도?

- 이메일, 전화번호 등을 활용한 soft-matching (❌ 개인정보 이슈)
- 비정형적 행동 패턴을 통한 Probabilistic Matching (❗비신뢰성)

결국, 서비스 성격에 따라 **Cross-device tracking이 필요한지 여부를 판단**해야 하고
이를 통해 그냥 기획상 존재해서 만들던 로그인 기능의 의미를 다시 한 번 더 생각해 볼 수가 있다.

---

## 2. 이벤트의 홍수에 휩쓸리다...

처음에는 가능하면 많이 다는 것이 좋다고 생각했다. 그러나 좋지 않은 예시들을 보면, **이벤트가 너무 많으면 어떤 정보를 봐야 할지 몰라지는 역효과**가 발생한다고 하는데...

우리는 CBL (Challenge Based Learning)이라는 프레임워크를 접했다. 어떻게 적용해볼까?

전 : 유저 행동은 결국 어떤 화면에 접근하고, 어떤 컴포넌트를 누르느냐 아님? 이벤트 다 추적하면 되는 거 아님? 기획자나 뭐.. 아무튼 나 아닌 누군가가 알아서 분석해주겠지!

후 : 우리는 왜 유저의 행동을 추적해야하는데? 뭣 땜에? 도대체 뭘 위해서?

그렇다. CBL을 하고나니, 이벤트를 심을 생명주기와 컴포넌트가 있으니 냅다 심어버리는 것이 아닌, **왜 이 이벤트를 심는가**를 먼저 묻는 구조가된다.

> **[목표와 지표부터 시작하세요](https://amplitude.com/blog/analytics-tracking-practices)**
> 먼저 평가 기준을 간략하게 설명한 다음 해당 평가 기준에 대해 적절하게 보고해야 하는 이벤트에 대해 간략하게 진행하는 것이 중요합니다. 목표, 지표 및 이벤트 간의 연결이 없으면 실제로 필요하지 않은 추적 계획과 데이터를 망라놓치게 될 가능성이 높으며 비즈니스에 중요한 이벤트를 놓치게 됩니다.
>
> | 목표   | 1분기에 인수를 15% 증가            |
> | ------ | ---------------------------------- |
> | 미터법 | 전환율 = 가입한 사용자/고유 방문자 |
> | 이벤트 | 가입한 사용자                      |
> | 속성   | user_id, 캠페인, 실험, 참조자 등   |
>
> 또한 계측을 위한 이벤트의 우선 순위를 정하는 데 도움이 되며 제품 관리자와 데이터 분석가가 새로운 기능의 목표 또는 성공 지표뿐만 아니라 이를 측정하는 데 필요한 제품에서 필요한 실제 추적으로 어떻게 변환되는지에 대해 생각하도록 할 수 있기를 바랍니다.

---

## 3. 과식보단 소식이 건강에 좋다

- `page_view`, `onAppear`, `onChange` 등 과도하게 붙인 이벤트는 노이즈가 된다
- 지표를 설계하지 않은 이벤트는 **결국 아무도 안 본다**
- 예를 들어, "유저가 날씨를 선택했다"는 행동을 **슬라이더를 바꿀 때마다 기록하는가, 저장을 눌렀을 때 한 번 기록하는가**는 완전히 다른 해석을 낳는다

결론적으로는, **사용자 인텐트가 실현된 시점**에만 이벤트를 로깅해야 한다는 통찰을 얻을 수 있다.

| 레퍼런스          | 핵심 메시지                                                                                                                                                                                             |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Woopra**        | [“More data … can make you miss the big truck.” — 지나친 데이터는 핵심 인사이트를 놓치게 하는 함정입니다](https://www.woopra.com/blog/event-tracking-mistakes).                                         |
| **Amplitude**     | [하나의 이벤트 텍소노미는 **10~200개 이내의 이벤트**로 구성해야 합니다. 과도한 이벤트는 분석 모델을 해치고 관리도 어려워집니다](https://amplitude.com/blog/event-tracking-pitfalls).                    |
| **Databox (GA4)** | [GA4에서는 모든 이벤트가 분석에 유의미한 것은 아닙니다. `add_to_cart` → `purchase` 같은 전환 중심 이벤트에 집중하는 것이 분석의 효율을 높입니다](https://databox.com/events-report-google-analytics-4). |
| **Mando Group**   | [“데이터 과밀은 오히려 의사결정을 방해합니다. 80%가 직접 활용되지 않는 정크 데이터”](https://www.mandogroup.com/news-insights/pitfalls-of-over-implementation).                                         |

---

## 4. 찌를 때마다 돈입니다... Debounce & Throttle

유저의 행동은 생각보다 **고빈도**로 발생한다. 특히 슬라이더, 스크롤, 키 입력, 제스처 등은 사용자가 한 번의 인텐트를 표현하기 위해 수십 번의 이벤트를 발생시킬 수도 있다.

이런 경우, 정말 모든 이벤트를 기록해야 할까? 무지성 호출 하기 전에 한번쯤 고려해봐야한다.

> 예: 유저가 온도 슬라이더를 18도에서 25도로 움직였다고 하자. 이걸 모든 중간 값(19, 20, 21...)으로 로깅해야 할까?

절대 아니다. 그래서 필요한 것이 **Debounce**와 **Throttle** 개념이다.

- **Debounce**: 이벤트가 연속적으로 발생할 때, 마지막 이벤트만 실행
  → 예: 유저가 텍스트를 입력할 때, 입력을 멈춘 뒤 1초 후 이벤트 발생
- **Throttle**: 이벤트가 연속적으로 발생할 때, 일정 주기로만 실행
  → 예: 유저가 스크롤할 때, 500ms 단위로만 이벤트 발생

이런 처리를 하지 않으면, 서버나 이벤트 툴이 감당 못할 **로그 폭탄**이 발생할 수 있다. 실제로 Firebase나 Amplitude에서도 초당 수십 건의 이벤트가 들어오면 **이상 탐지 시스템에 걸리거나 요금 폭탄**이 나올 수 있다.

이벤트를 로깅하는 것은 **사용자 행동을 기록하는 것**이지만, 그 행동은 "해석 가능한 단위"로 축소되어야 한다. 그게 바로 개발자가 고려해야 할 책임이다.

---

## 5. 이벤트 네이밍, 변수명만큼 중요하다

이벤트 설계에서 종종 간과되는 요소가 바로 **이름**이다.
하지만 이름은 그 자체로 **의미를 부여하고 해석을 유도하는 메타데이터**다.

> 예: `click_button` vs `submit_feedback`

- `click_button`이라는 이름은 UI의 단순 인터랙션을 설명할 뿐이다.
- 반면, `submit_feedback`은 유저의 **의도**와 **비즈니스 목적**을 더 명확히 보여준다.

### 네이밍이 잘못되면?

- **협업자가 이벤트 목적을 오해**한다 (디자이너/PM/데이터 분석가)
- 대시보드 상에서 **해석 가능한 흐름을 구성할 수 없다**
- A/B 테스트나 리텐션 분석 시, **무의미한 지표로 이어질 수 있다**

### 그래서 어떤 방식이 좋을까?

- `action_object` 형태 → `submit_form`, `select_plan`, `view_screen`
- snake_case 또는 dot.notation → 도구에 따라 제한 있음 (Amplitude는 dot 권장)

### 중요한 건 일관성

한 프로젝트 안에서 이벤트 네이밍 방식이 다르면,
나중에 도대체 **이벤트가 어떤 의미인지**, 누가 만들었는지, 왜 있는지 파악하는 데만 하루가 걸린다.

**이벤트는 이름부터가 해석이다.**
따라서, 설계 초기 단계부터 네이밍 룰을 문서화하고 팀과 공유하는 것이 중요하다.
